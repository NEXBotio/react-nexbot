/* tslint:disable */
/* eslint-disable */
/**
 * Nexbot API
 * NexBot API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AIMessage
 */
export interface AIMessage {
    /**
     * 
     * @type {string}
     * @memberof AIMessage
     */
    'content': string;
    /**
     * 
     * @type {SenderType}
     * @memberof AIMessage
     */
    'sender_type': SenderType;
    /**
     * 
     * @type {boolean}
     * @memberof AIMessage
     */
    'is_streaming': boolean;
    /**
     * 
     * @type {number}
     * @memberof AIMessage
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof AIMessage
     */
    'sender_readable_name': string;
    /**
     * 
     * @type {string}
     * @memberof AIMessage
     */
    'id': string;
    /**
     * 
     * @type {Array<Source>}
     * @memberof AIMessage
     */
    'sources'?: Array<Source>;
    /**
     * 
     * @type {Conversation}
     * @memberof AIMessage
     */
    'conversation': Conversation;
    /**
     * 
     * @type {string}
     * @memberof AIMessage
     */
    'bot_id': string;
}


/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    'has_photo': boolean;
    /**
     * 
     * @type {number}
     * @memberof Bot
     */
    'token_rate': number;
    /**
     * 
     * @type {number}
     * @memberof Bot
     */
    'effective_token_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Bot
     */
    'time_created'?: number;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'storefront_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'created_by_id'?: string;
    /**
     * 
     * @type {BotPhotoURL}
     * @memberof Bot
     */
    'photo_url'?: BotPhotoURL;
    /**
     * 
     * @type {number}
     * @memberof Bot
     */
    'accrued_tokens': number;
    /**
     * 
     * @type {BotStatus}
     * @memberof Bot
     */
    'status': BotStatus;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'bot_type_id': string;
    /**
     * 
     * @type {number}
     * @memberof Bot
     */
    'token_purse': number;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    'is_public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    'preserve_short_link_id'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'qr_code_image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'bot_intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'profile_image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'short_link_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'photo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'shared_alias'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Bot
     */
    'property_values': Array<object>;
    /**
     * 
     * @type {object}
     * @memberof Bot
     */
    'init_values': object;
    /**
     * 
     * @type {object}
     * @memberof Bot
     */
    'setup_values': object;
}


/**
 * 
 * @export
 * @interface BotPage
 */
export interface BotPage {
    /**
     * 
     * @type {string}
     * @memberof BotPage
     */
    'cursor'?: string;
    /**
     * 
     * @type {Array<BotPublicInterface>}
     * @memberof BotPage
     */
    'bots': Array<BotPublicInterface>;
}
/**
 * 
 * @export
 * @interface BotPhotoURL
 */
export interface BotPhotoURL {
    /**
     * 
     * @type {string}
     * @memberof BotPhotoURL
     */
    'bot_id': string;
    /**
     * 
     * @type {number}
     * @memberof BotPhotoURL
     */
    'expiration_time': number;
    /**
     * 
     * @type {string}
     * @memberof BotPhotoURL
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface BotPublicInterface
 */
export interface BotPublicInterface {
    /**
     * 
     * @type {boolean}
     * @memberof BotPublicInterface
     */
    'has_photo': boolean;
    /**
     * 
     * @type {number}
     * @memberof BotPublicInterface
     */
    'token_rate': number;
    /**
     * 
     * @type {number}
     * @memberof BotPublicInterface
     */
    'effective_token_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof BotPublicInterface
     */
    'time_created'?: number;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'storefront_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'created_by_id'?: string;
    /**
     * 
     * @type {BotPhotoURL}
     * @memberof BotPublicInterface
     */
    'photo_url'?: BotPhotoURL;
    /**
     * 
     * @type {number}
     * @memberof BotPublicInterface
     */
    'accrued_tokens': number;
    /**
     * 
     * @type {BotStatus}
     * @memberof BotPublicInterface
     */
    'status': BotStatus;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'bot_type_id': string;
    /**
     * 
     * @type {number}
     * @memberof BotPublicInterface
     */
    'token_purse': number;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BotPublicInterface
     */
    'is_public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BotPublicInterface
     */
    'preserve_short_link_id'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'qr_code_image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'bot_intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'profile_image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPublicInterface
     */
    'short_link_id'?: string;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const BotStatus = {
    Initializing: 'initializing',
    Ready: 'ready',
    Failed: 'failed',
    NotInitialized: 'not_initialized'
} as const;

export type BotStatus = typeof BotStatus[keyof typeof BotStatus];


/**
 * 
 * @export
 * @interface BotType
 */
export interface BotType {
    /**
     * 
     * @type {string}
     * @memberof BotType
     */
    'photo_s3_location': string;
    /**
     * 
     * @type {string}
     * @memberof BotType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BotType
     */
    'display_name': string;
    /**
     * 
     * @type {Procedure}
     * @memberof BotType
     */
    'setup_procedure': Procedure;
    /**
     * 
     * @type {Procedure}
     * @memberof BotType
     */
    'init_procedure': Procedure;
    /**
     * 
     * @type {Array<BotUIProperty>}
     * @memberof BotType
     */
    'definition_template': Array<BotUIProperty>;
    /**
     * 
     * @type {Array<{ [key: string]: Array<string>; }>}
     * @memberof BotType
     */
    'tags': Array<{ [key: string]: Array<string>; }>;
    /**
     * 
     * @type {string}
     * @memberof BotType
     */
    'qr_photo_s3_location'?: string;
}
/**
 * 
 * @export
 * @interface BotUIProperty
 */
export interface BotUIProperty {
    /**
     * 
     * @type {string}
     * @memberof BotUIProperty
     */
    'display_text': string;
    /**
     * 
     * @type {string}
     * @memberof BotUIProperty
     */
    'component_name': string;
    /**
     * 
     * @type {Array<ExpectedOutput>}
     * @memberof BotUIProperty
     */
    'expected_output': Array<ExpectedOutput>;
    /**
     * 
     * @type {any}
     * @memberof BotUIProperty
     */
    'default_value'?: any;
    /**
     * 
     * @type {Array<ReactProp>}
     * @memberof BotUIProperty
     */
    'component_props': Array<ReactProp>;
}
/**
 * 
 * @export
 * @interface ChatHistory
 */
export interface ChatHistory {
    /**
     * 
     * @type {UserInfo}
     * @memberof ChatHistory
     */
    'user'?: UserInfo;
    /**
     * 
     * @type {Array<MessagesInner>}
     * @memberof ChatHistory
     */
    'messages'?: Array<MessagesInner>;
    /**
     * 
     * @type {Conversation}
     * @memberof ChatHistory
     */
    'conversation'?: Conversation;
}
/**
 * 
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'id'?: string;
    /**
     * 
     * @type {ConnectionType}
     * @memberof Connection
     */
    'connection_type': ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'bot_id': string;
    /**
     * 
     * @type {object}
     * @memberof Connection
     */
    'subclass_data'?: object;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'email': string;
    /**
     * 
     * @type {EmailAction}
     * @memberof Connection
     */
    'email_action': EmailAction;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'forwarding_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'instructions': string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'api_url': string;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ConnectionType = {
    Email: 'email'
} as const;

export type ConnectionType = typeof ConnectionType[keyof typeof ConnectionType];


/**
 * 
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * 
     * @type {string}
     * @memberof Conversation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Conversation
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof Conversation
     */
    'chat_history_doc_id': string;
    /**
     * 
     * @type {string}
     * @memberof Conversation
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Conversation
     */
    'bot_id': string;
    /**
     * 
     * @type {string}
     * @memberof Conversation
     */
    'bot_readable_name': string;
}
/**
 * 
 * @export
 * @interface DocumentArchive
 */
export interface DocumentArchive {
    /**
     * 
     * @type {string}
     * @memberof DocumentArchive
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: DocumentArchiveFile; }}
     * @memberof DocumentArchive
     */
    'contained_files': { [key: string]: DocumentArchiveFile; };
    /**
     * 
     * @type {string}
     * @memberof DocumentArchive
     */
    'namespace'?: string;
    /**
     * 
     * @type {PineconeIndex}
     * @memberof DocumentArchive
     */
    'index'?: PineconeIndex;
}
/**
 * 
 * @export
 * @interface DocumentArchiveFile
 */
export interface DocumentArchiveFile {
    /**
     * 
     * @type {string}
     * @memberof DocumentArchiveFile
     */
    'file_name': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentArchiveFile
     */
    'total_vectors': number;
    /**
     * 
     * @type {Tag}
     * @memberof DocumentArchiveFile
     */
    'tag'?: Tag;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentArchiveFile
     */
    'vector_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DocumentArchiveMultipleDocPutBody
 */
export interface DocumentArchiveMultipleDocPutBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentArchiveMultipleDocPutBody
     */
    'new_doc_names': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DocumentArchiveMultipleDocPutBody
     */
    'document_archive_id': string;
}
/**
 * 
 * @export
 * @interface DocumentArchiveRESTBody
 */
export interface DocumentArchiveRESTBody {
    /**
     * 
     * @type {string}
     * @memberof DocumentArchiveRESTBody
     */
    'new_doc_name': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentArchiveRESTBody
     */
    'document_archive_id': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EmailAction = {
    Forward: 'forward',
    Reply: 'reply'
} as const;

export type EmailAction = typeof EmailAction[keyof typeof EmailAction];


/**
 * 
 * @export
 * @interface EmailConnection
 */
export interface EmailConnection {
    /**
     * 
     * @type {string}
     * @memberof EmailConnection
     */
    'id'?: string;
    /**
     * 
     * @type {ConnectionType}
     * @memberof EmailConnection
     */
    'connection_type'?: ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof EmailConnection
     */
    'bot_id': string;
    /**
     * 
     * @type {object}
     * @memberof EmailConnection
     */
    'subclass_data'?: object;
    /**
     * 
     * @type {string}
     * @memberof EmailConnection
     */
    'email': string;
    /**
     * 
     * @type {EmailAction}
     * @memberof EmailConnection
     */
    'email_action': EmailAction;
    /**
     * 
     * @type {string}
     * @memberof EmailConnection
     */
    'forwarding_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConnection
     */
    'instructions': string;
}


/**
 * 
 * @export
 * @interface ExpectedOutput
 */
export interface ExpectedOutput {
    /**
     * 
     * @type {string}
     * @memberof ExpectedOutput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExpectedOutput
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ExternalBotModificationRESTBody
 */
export interface ExternalBotModificationRESTBody {
    /**
     * 
     * @type {string}
     * @memberof ExternalBotModificationRESTBody
     */
    'bot_id': string;
    /**
     * 
     * @type {object}
     * @memberof ExternalBotModificationRESTBody
     */
    'modified_bot': object;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HumanMessage
 */
export interface HumanMessage {
    /**
     * 
     * @type {string}
     * @memberof HumanMessage
     */
    'content': string;
    /**
     * 
     * @type {SenderType}
     * @memberof HumanMessage
     */
    'sender_type': SenderType;
    /**
     * 
     * @type {boolean}
     * @memberof HumanMessage
     */
    'is_streaming': boolean;
    /**
     * 
     * @type {number}
     * @memberof HumanMessage
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof HumanMessage
     */
    'sender_readable_name': string;
    /**
     * 
     * @type {string}
     * @memberof HumanMessage
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanMessage
     */
    'id': string;
    /**
     * 
     * @type {Conversation}
     * @memberof HumanMessage
     */
    'conversation': Conversation;
    /**
     * 
     * @type {string}
     * @memberof HumanMessage
     */
    'user_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof HumanMessage
     */
    'recipient_bot_id': string;
    /**
     * 
     * @type {Connection}
     * @memberof HumanMessage
     */
    'connection'?: Connection;
}


/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LogIn
 */
export interface LogIn {
    /**
     * 
     * @type {string}
     * @memberof LogIn
     */
    'device'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogIn
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogIn
     */
    'geography'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogIn
     */
    'browser'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogIn
     */
    'precedence'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {UserInfo}
     * @memberof LoginResponse
     */
    'user_info': UserInfo;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    'is_sign_up'?: boolean;
    /**
     * 
     * @type {SessionToken}
     * @memberof LoginResponse
     */
    'session_token': SessionToken;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MessagesInner
 */
export interface MessagesInner {
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'content': string;
    /**
     * 
     * @type {SenderType}
     * @memberof MessagesInner
     */
    'sender_type': SenderType;
    /**
     * 
     * @type {boolean}
     * @memberof MessagesInner
     */
    'is_streaming': boolean;
    /**
     * 
     * @type {number}
     * @memberof MessagesInner
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'sender_readable_name': string;
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'id': string;
    /**
     * 
     * @type {Conversation}
     * @memberof MessagesInner
     */
    'conversation': Conversation;
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'user_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'recipient_bot_id': string;
    /**
     * 
     * @type {Connection}
     * @memberof MessagesInner
     */
    'connection'?: Connection;
    /**
     * 
     * @type {Array<Source>}
     * @memberof MessagesInner
     */
    'sources'?: Array<Source>;
    /**
     * 
     * @type {string}
     * @memberof MessagesInner
     */
    'bot_id': string;
}


/**
 * 
 * @export
 * @interface PineconeIndex
 */
export interface PineconeIndex {
    /**
     * 
     * @type {string}
     * @memberof PineconeIndex
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PineconeIndex
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof PineconeIndex
     */
    'dimensions': number;
    /**
     * 
     * @type {string}
     * @memberof PineconeIndex
     */
    'metric': string;
}
/**
 * 
 * @export
 * @interface PineconeUsage
 */
export interface PineconeUsage {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof PineconeUsage
     */
    'document_vector_counts': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof PineconeUsage
     */
    'vector_quota': number;
    /**
     * 
     * @type {number}
     * @memberof PineconeUsage
     */
    'total_vectors': number;
    /**
     * 
     * @type {number}
     * @memberof PineconeUsage
     */
    'usage': number;
}
/**
 * 
 * @export
 * @interface Procedure
 */
export interface Procedure {
    /**
     * 
     * @type {string}
     * @memberof Procedure
     */
    'function_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Procedure
     */
    'args': Array<string>;
}
/**
 * 
 * @export
 * @interface ReactProp
 */
export interface ReactProp {
    /**
     * 
     * @type {string}
     * @memberof ReactProp
     */
    'prop_name': string;
    /**
     * 
     * @type {any}
     * @memberof ReactProp
     */
    'prop_value'?: any;
}
/**
 * 
 * @export
 * @interface ResponseAddPublicBotBotsAddedBotIdGet
 */
export interface ResponseAddPublicBotBotsAddedBotIdGet {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'has_photo': boolean;
    /**
     * 
     * @type {number}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'token_rate': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'effective_token_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'time_created'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'storefront_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'created_by_id'?: string;
    /**
     * 
     * @type {BotPhotoURL}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'photo_url'?: BotPhotoURL;
    /**
     * 
     * @type {number}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'accrued_tokens': number;
    /**
     * 
     * @type {BotStatus}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'status': BotStatus;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'bot_type_id': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'token_purse': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'is_public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'preserve_short_link_id'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'qr_code_image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'bot_intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'profile_image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'short_link_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'photo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'shared_alias'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'property_values': Array<object>;
    /**
     * 
     * @type {object}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'init_values': object;
    /**
     * 
     * @type {object}
     * @memberof ResponseAddPublicBotBotsAddedBotIdGet
     */
    'setup_values': object;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const SenderType = {
    Human: 'human',
    Ai: 'ai',
    Advertiser: 'advertiser',
    System: 'system'
} as const;

export type SenderType = typeof SenderType[keyof typeof SenderType];


/**
 * 
 * @export
 * @interface SessionToken
 */
export interface SessionToken {
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    'access_expiration': string;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    'refresh_expiration': string;
    /**
     * 
     * @type {string}
     * @memberof SessionToken
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface ShortCutList
 */
export interface ShortCutList {
    /**
     * 
     * @type {Array<string>}
     * @memberof ShortCutList
     */
    'bot_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'page_content': string;
    /**
     * 
     * @type {SourceMetadata}
     * @memberof Source
     */
    'metadata': SourceMetadata;
}
/**
 * 
 * @export
 * @interface SourceMetadata
 */
export interface SourceMetadata {
    /**
     * 
     * @type {string}
     * @memberof SourceMetadata
     */
    'file_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceMetadata
     */
    'file_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceMetadata
     */
    'file_path'?: string;
}
/**
 * 
 * @export
 * @interface Storefront
 */
export interface Storefront {
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'public_id': string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'owner_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'business_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'business_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'business_address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Storefront
     */
    'preserve_short_link_id'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Storefront
     */
    'short_link_id'?: string;
}
/**
 * 
 * @export
 * @interface StorefrontLogin
 */
export interface StorefrontLogin {
    /**
     * 
     * @type {Storefront}
     * @memberof StorefrontLogin
     */
    'storefront': Storefront;
    /**
     * 
     * @type {LogIn}
     * @memberof StorefrontLogin
     */
    'user_login': LogIn;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'end': number;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tag': string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'interest': number;
}
/**
 * 
 * @export
 * @interface TextToVoiceConnection
 */
export interface TextToVoiceConnection {
    /**
     * 
     * @type {string}
     * @memberof TextToVoiceConnection
     */
    'id'?: string;
    /**
     * 
     * @type {ConnectionType}
     * @memberof TextToVoiceConnection
     */
    'connection_type': ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof TextToVoiceConnection
     */
    'bot_id': string;
    /**
     * 
     * @type {object}
     * @memberof TextToVoiceConnection
     */
    'subclass_data'?: object;
    /**
     * 
     * @type {string}
     * @memberof TextToVoiceConnection
     */
    'api_url': string;
}


/**
 * 
 * @export
 * @interface TokenQuantity
 */
export interface TokenQuantity {
    /**
     * 
     * @type {number}
     * @memberof TokenQuantity
     */
    'quantity': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TypeOfUser = {
    Paid: 'paid',
    Free: 'free',
    System: 'system',
    Anon: 'anon',
    Registered: 'registered'
} as const;

export type TypeOfUser = typeof TypeOfUser[keyof typeof TypeOfUser];


/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'uid': string;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    'token_version'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    'server_secret_version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'server_secret_first_letters'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'server_secret_last_letters'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    'single_use_token_version'?: number;
    /**
     * 
     * @type {TypeOfUser}
     * @memberof UserInfo
     */
    'user_type'?: TypeOfUser;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    'tokens'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'stripe_id'?: string;
    /**
     * 
     * @type {VectorStorage}
     * @memberof UserInfo
     */
    'vector_storage': VectorStorage;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'email'?: string;
    /**
     * 
     * @type {Subscription}
     * @memberof UserInfo
     */
    'storage_subscription'?: Subscription;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'last_bot_built'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'photo_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfo
     */
    'storefront_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'active_storefront_id'?: string;
}


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface VectorStorage
 */
export interface VectorStorage {
    /**
     * 
     * @type {number}
     * @memberof VectorStorage
     */
    'quota': number;
    /**
     * 
     * @type {number}
     * @memberof VectorStorage
     */
    'used_vectors': number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Bot To Shortcuts
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBotToShortcutsShortcutsAddBotPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('addBotToShortcutsShortcutsAddBotPut', 'botId', botId)
            const localVarPath = `/shortcuts/add_bot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (botId !== undefined) {
                localVarQueryParameter['bot_id'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Document Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentArchiveDocumentArchivesUsersPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/document_archives/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Multiple Documents To Doc Archive
         * @param {DocumentArchiveMultipleDocPutBody} documentArchiveMultipleDocPutBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut: async (documentArchiveMultipleDocPutBody: DocumentArchiveMultipleDocPutBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentArchiveMultipleDocPutBody' is not null or undefined
            assertParamExists('addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut', 'documentArchiveMultipleDocPutBody', documentArchiveMultipleDocPutBody)
            const localVarPath = `/document_archives/multidoc/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentArchiveMultipleDocPutBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add New Bot
         * @param {Bot} bot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewBotBotsCreatePost: async (bot: Bot, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bot' is not null or undefined
            assertParamExists('addNewBotBotsCreatePost', 'bot', bot)
            const localVarPath = `/bots/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add New User
         * @param {string} userId 
         * @param {string} displayName 
         * @param {string} email 
         * @param {string} photoUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewUserAdminAddNewUserPost: async (userId: string, displayName: string, email: string, photoUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addNewUserAdminAddNewUserPost', 'userId', userId)
            // verify required parameter 'displayName' is not null or undefined
            assertParamExists('addNewUserAdminAddNewUserPost', 'displayName', displayName)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('addNewUserAdminAddNewUserPost', 'email', email)
            // verify required parameter 'photoUrl' is not null or undefined
            assertParamExists('addNewUserAdminAddNewUserPost', 'photoUrl', photoUrl)
            const localVarPath = `/admin/add_new_user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (photoUrl !== undefined) {
                localVarQueryParameter['photo_url'] = photoUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Pinecone Index
         * @param {PineconeIndex} pineconeIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPineconeIndexVectorstoresPineconeIndicesPost: async (pineconeIndex: PineconeIndex, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pineconeIndex' is not null or undefined
            assertParamExists('addPineconeIndexVectorstoresPineconeIndicesPost', 'pineconeIndex', pineconeIndex)
            const localVarPath = `/vectorstores/pinecone/indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pineconeIndex, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Public Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPublicBotBotsAddedBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('addPublicBotBotsAddedBotIdGet', 'botId', botId)
            const localVarPath = `/bots/added/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete Wix Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWixLoginCompleteWixLoginGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/complete_wix_login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm Image Upload
         * @param {any} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmImageUploadUtilsConfirmImageUploadImageNamePut: async (imageName: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('confirmImageUploadUtilsConfirmImageUploadImageNamePut', 'imageName', imageName)
            const localVarPath = `/utils/confirm_image_upload/{image_name}`
                .replace(`{${"image_name"}}`, encodeURIComponent(String(imageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Email Connection
         * @param {EmailConnection} emailConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailConnectionConnectionsEmailPost: async (emailConnection: EmailConnection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailConnection' is not null or undefined
            assertParamExists('createEmailConnectionConnectionsEmailPost', 'emailConnection', emailConnection)
            const localVarPath = `/connections/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailConnection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete All Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllDataAdminDeleteAllDataDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/delete_all_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionConnectionsDeleteConnectionIdDelete: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteConnectionConnectionsDeleteConnectionIdDelete', 'connectionId', connectionId)
            const localVarPath = `/connections/delete/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Conversation
         * @param {string} botId 
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationDeleteConvByIdBotIdConversationIdDelete: async (botId: string, conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('deleteConversationDeleteConvByIdBotIdConversationIdDelete', 'botId', botId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversationDeleteConvByIdBotIdConversationIdDelete', 'conversationId', conversationId)
            const localVarPath = `/delete_conv_by_id/{bot_id}/{conversation_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document Archive
         * @param {string} documentArchiveId 
         * @param {boolean} [deleteFromPinecone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete: async (documentArchiveId: string, deleteFromPinecone?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentArchiveId' is not null or undefined
            assertParamExists('deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete', 'documentArchiveId', documentArchiveId)
            const localVarPath = `/document_archive/{document_archive_id}`
                .replace(`{${"document_archive_id"}}`, encodeURIComponent(String(documentArchiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deleteFromPinecone !== undefined) {
                localVarQueryParameter['delete_from_pinecone'] = deleteFromPinecone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document Archive File
         * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentArchiveFileDocumentArchiveFilePut: async (documentArchiveRESTBody: DocumentArchiveRESTBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentArchiveRESTBody' is not null or undefined
            assertParamExists('deleteDocumentArchiveFileDocumentArchiveFilePut', 'documentArchiveRESTBody', documentArchiveRESTBody)
            const localVarPath = `/document_archive_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentArchiveRESTBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Pinecone Document
         * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePineconeDocumentDocumentPineconeFilePut: async (documentArchiveRESTBody: DocumentArchiveRESTBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentArchiveRESTBody' is not null or undefined
            assertParamExists('deletePineconeDocumentDocumentPineconeFilePut', 'documentArchiveRESTBody', documentArchiveRESTBody)
            const localVarPath = `/document_pinecone_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentArchiveRESTBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User Bot
         * @param {any} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserBotBotsByIdBotIdDelete: async (botId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('deleteUserBotBotsByIdBotIdDelete', 'botId', botId)
            const localVarPath = `/bots/by_id/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Describe Pinecone Index
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet', 'id', id)
            const localVarPath = `/vectorstores/pinecone/indices/{id}/describe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Externaly Modify Bot
         * @param {ExternalBotModificationRESTBody} externalBotModificationRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalyModifyBotExternalModifyBotPut: async (externalBotModificationRESTBody: ExternalBotModificationRESTBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalBotModificationRESTBody' is not null or undefined
            assertParamExists('externalyModifyBotExternalModifyBotPut', 'externalBotModificationRESTBody', externalBotModificationRESTBody)
            const localVarPath = `/external_modify_bot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalBotModificationRESTBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Email
         * @param {number} numberOfWords 
         * @param {string} name 
         * @param {number} [numberOfAttempts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEmailUtilsGenerateEmailGet: async (numberOfWords: number, name: string, numberOfAttempts?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'numberOfWords' is not null or undefined
            assertParamExists('generateEmailUtilsGenerateEmailGet', 'numberOfWords', numberOfWords)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('generateEmailUtilsGenerateEmailGet', 'name', name)
            const localVarPath = `/utils/generate_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (numberOfWords !== undefined) {
                localVarQueryParameter['number_of_words'] = numberOfWords;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (numberOfAttempts !== undefined) {
                localVarQueryParameter['number_of_attempts'] = numberOfAttempts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Presigned Url
         * @param {string} objectName 
         * @param {string} objectType 
         * @param {boolean} [docUpload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePresignedUrlUtilsGenerateS3UploadUrlGet: async (objectName: string, objectType: string, docUpload?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('generatePresignedUrlUtilsGenerateS3UploadUrlGet', 'objectName', objectName)
            // verify required parameter 'objectType' is not null or undefined
            assertParamExists('generatePresignedUrlUtilsGenerateS3UploadUrlGet', 'objectType', objectType)
            const localVarPath = `/utils/generate_s3_upload_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (objectName !== undefined) {
                localVarQueryParameter['object_name'] = objectName;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (docUpload !== undefined) {
                localVarQueryParameter['doc_upload'] = docUpload;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Single Use Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSingleUseTokenSecretsGenerateSingleUseTokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/generate_single_use_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Added Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddedBotsBotsAddedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Bot Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBotTypeBotTypesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bot_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Bots For User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBotsForUserBotsAllbotsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/allbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bot
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotBotsByIdIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBotBotsByIdIdGet', 'id', id)
            const localVarPath = `/bots/by_id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bot Connections
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotConnectionsConnectionsGetAllBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getBotConnectionsConnectionsGetAllBotIdGet', 'botId', botId)
            const localVarPath = `/connections/get_all/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bot Photo Url
         * @param {string} botId 
         * @param {number} [secondsToExpiry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotPhotoUrlBotsBotPhotoUrlBotIdGet: async (botId: string, secondsToExpiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getBotPhotoUrlBotsBotPhotoUrlBotIdGet', 'botId', botId)
            const localVarPath = `/bots/bot_photo_url/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (secondsToExpiry !== undefined) {
                localVarQueryParameter['seconds_to_expiry'] = secondsToExpiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bot Shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotShortcutsShortcutsGetAllGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shortcuts/get_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bot Type
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotTypeBotTypesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBotTypeBotTypesIdGet', 'id', id)
            const localVarPath = `/bot_types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bots
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotsBotsByIdsGet: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getBotsBotsByIdsGet', 'requestBody', requestBody)
            const localVarPath = `/bots/by_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Bots For Storefront
         * @param {string} storefrontId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet: async (storefrontId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storefrontId' is not null or undefined
            assertParamExists('getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet', 'storefrontId', storefrontId)
            const localVarPath = `/bots/get_bots_for_storefront/{storefront_id}`
                .replace(`{${"storefront_id"}}`, encodeURIComponent(String(storefrontId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Builtin Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltinBotsListAllSystemBotsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/list_all_system_bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Conversations By User
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationsByUserConversationsBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getConversationsByUserConversationsBotIdGet', 'botId', botId)
            const localVarPath = `/conversations/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Document Archive From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet', 'botId', botId)
            const localVarPath = `/bots/get_user_bot_document_archive_id/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Document Archives
         * @param {string} [docId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentArchivesDocumentArchivesGet: async (docId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/document_archives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (docId !== undefined) {
                localVarQueryParameter['doc_id'] = docId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Init Values From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet', 'botId', botId)
            const localVarPath = `/bots/get_user_bot_init_values/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Messages By Conversation
         * @param {string} botId 
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesByConversationConversationsByIdBotIdConversationIdGet: async (botId: string, conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getMessagesByConversationConversationsByIdBotIdConversationIdGet', 'botId', botId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getMessagesByConversationConversationsByIdBotIdConversationIdGet', 'conversationId', conversationId)
            const localVarPath = `/conversations_by_id/{bot_id}/{conversation_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Paginated Bots Added
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBotsAddedBotsPaginateAddedGet: async (cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/paginate/added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (isAsc !== undefined) {
                localVarQueryParameter['is_asc'] = isAsc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Paginated Bots Shared
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBotsSharedBotsPaginateSharedGet: async (cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/paginate/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (isAsc !== undefined) {
                localVarQueryParameter['is_asc'] = isAsc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Paginated Bots User
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBotsUserBotsPaginateUserGet: async (cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/paginate/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (isAsc !== undefined) {
                localVarQueryParameter['is_asc'] = isAsc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Pinecone Index
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeIndexVectorstoresDescribePineconeIndicesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPineconeIndexVectorstoresDescribePineconeIndicesIdGet', 'id', id)
            const localVarPath = `/vectorstores/describe_pinecone/indices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Pinecone Index
         * @param {string} indexId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeIndexVectorstoresPineconeIndicesIndexIdGet: async (indexId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexId' is not null or undefined
            assertParamExists('getPineconeIndexVectorstoresPineconeIndicesIndexIdGet', 'indexId', indexId)
            const localVarPath = `/vectorstores/pinecone/indices/{index_id}`
                .replace(`{${"index_id"}}`, encodeURIComponent(String(indexId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Pinecone Indices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeIndicesVectorstoresPineconeIndicesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vectorstores/pinecone/indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Pinecone Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeUsageUsersVectorstoresPineconeUsageGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/vectorstores/pinecone/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Server Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSecretSecretsRefreshGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Setup Values From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet', 'botId', botId)
            const localVarPath = `/bots/get_user_bot_setup_values/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Shared Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedBotsBotsAllSharedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/all_shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Shortcut Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortcutBotsBotsGetShortcutBotsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/get_shortcut_bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Store Front
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFrontUsersStorefrontGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/storefront`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBalanceUsersGetTokenBalanceGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/get_token_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token Rate
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenRateBotsGetTokenRateBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('getTokenRateBotsGetTokenRateBotIdGet', 'botId', botId)
            const localVarPath = `/bots/get_token_rate/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBotsBotsUserbotsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/userbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoUsersGetUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/get_user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ws Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWsTicketGetWsTicketGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/get_ws_ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Authed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAuthedIsAuthedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/is_authed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Storefront Used
         * @param {string} storefrontId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet: async (storefrontId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storefrontId' is not null or undefined
            assertParamExists('isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet', 'storefrontId', storefrontId)
            const localVarPath = `/users/is_storefront_used/{storefront_id}`
                .replace(`{${"storefront_id"}}`, encodeURIComponent(String(storefrontId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LogIn} logIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost: async (logIn: LogIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logIn' is not null or undefined
            assertParamExists('loginLoginPost', 'logIn', logIn)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login With Storefront
         * @param {StorefrontLogin} storefrontLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithStorefrontLoginWithStorefrontPost: async (storefrontLogin: StorefrontLogin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storefrontLogin' is not null or undefined
            assertParamExists('loginWithStorefrontLoginWithStorefrontPost', 'storefrontLogin', storefrontLogin)
            const localVarPath = `/login_with_storefront`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storefrontLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {boolean} [fromAllDevices] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutLogoutGet: async (fromAllDevices?: boolean, refreshToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromAllDevices !== undefined) {
                localVarQueryParameter['from_all_devices'] = fromAllDevices;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Make Bot Private
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeBotPrivateBotsMakeBotPrivateBotIdPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('makeBotPrivateBotsMakeBotPrivateBotIdPut', 'botId', botId)
            const localVarPath = `/bots/make_bot_private/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Make Bot Public
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeBotPublicBotsMakeBotPublicBotIdPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('makeBotPublicBotsMakeBotPublicBotIdPut', 'botId', botId)
            const localVarPath = `/bots/make_bot_public/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify Storefront
         * @param {Storefront} storefront 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyStorefrontUtilsModifyStorefrontPut: async (storefront: Storefront, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storefront' is not null or undefined
            assertParamExists('modifyStorefrontUtilsModifyStorefrontPut', 'storefront', storefront)
            const localVarPath = `/utils/modify_storefront`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storefront, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open Shared Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openSharedBotBotsSharedBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('openSharedBotBotsSharedBotIdGet', 'botId', botId)
            const localVarPath = `/bots/shared/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge All Document Archives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/purge_all_doc_archives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge All Messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllMessagesAdminPurgeAllMessagesDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/purge_all_messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge All Namespaces And Doc Archives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/purge_all_doc_archives_and_namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge All User Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllUserBotsAdminPurgeAllUserBotsDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/purge_all_user_bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHealthHealthGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Token Endpoint
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenEndpointRefreshTokenPost: async (refreshToken: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshTokenEndpointRefreshTokenPost', 'refreshToken', refreshToken)
            const localVarPath = `/refresh_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (refreshToken !== undefined) {
                localVarQueryParameter['refresh_token'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Added Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAddedBotBotsRemoveAddedBotIdPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('removeAddedBotBotsRemoveAddedBotIdPut', 'botId', botId)
            const localVarPath = `/bots/remove_added/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Bot From Shortcuts
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBotFromShortcutsShortcutsRemoveBotPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('removeBotFromShortcutsShortcutsRemoveBotPut', 'botId', botId)
            const localVarPath = `/shortcuts/remove_bot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (botId !== undefined) {
                localVarQueryParameter['bot_id'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Server Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeServerSecretSecretsDeleteDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report Build Failure
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportBuildFailureBotsReportBuildFailureBotIdPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('reportBuildFailureBotsReportBuildFailureBotIdPut', 'botId', botId)
            const localVarPath = `/bots/report_build_failure/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report Build Success
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportBuildSuccessBotsReportBuildSuccessBotIdPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('reportBuildSuccessBotsReportBuildSuccessBotIdPut', 'botId', botId)
            const localVarPath = `/bots/report_build_success/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAdminUsersResetAdminPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/reset_admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset All Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAllDataAdminResetAllDataPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/reset_all_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Bot Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetBotTypesAdminRestoreBotTypesPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/restore_bot_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Bots
         * @param {boolean} [updateDocs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetBotsAdminRestoreBuiltinBotsPut: async (updateDocs?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/restore_builtin_bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (updateDocs !== undefined) {
                localVarQueryParameter['update_docs'] = updateDocs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Bots And Bot Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetBotsAndBotTypesAdminResetBotsAndBotTypesPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/reset_bots_and_bot_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Pinecone Indices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPineconeIndicesAdminResetPineconeIndicesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/reset_pinecone_indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Bot Share
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBotShareBotsStartShareBotIdGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('startBotShareBotsStartShareBotIdGet', 'botId', botId)
            const localVarPath = `/bots/start_share/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Wix Login
         * @param {LogIn} logIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startWixLoginStartWixLoginPost: async (logIn: LogIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logIn' is not null or undefined
            assertParamExists('startWixLoginStartWixLoginPost', 'logIn', logIn)
            const localVarPath = `/start_wix_login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop Bot Share
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBotShareBotsStopShareBotIdPut: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('stopBotShareBotsStopShareBotIdPut', 'botId', botId)
            const localVarPath = `/bots/stop_share/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stripe Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeWebhookWebhookStripePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Bot Status
         * @param {string} id 
         * @param {BotStatus} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotStatusBotsUpdateBotStatusIdPut: async (id: string, status: BotStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBotStatusBotsUpdateBotStatusIdPut', 'id', id)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateBotStatusBotsUpdateBotStatusIdPut', 'status', status)
            const localVarPath = `/bots/update_bot_status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Bot To Shortcuts
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBotToShortcutsShortcutsAddBotPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBotToShortcutsShortcutsAddBotPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Document Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDocumentArchiveDocumentArchivesUsersPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentArchive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDocumentArchiveDocumentArchivesUsersPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Multiple Documents To Doc Archive
         * @param {DocumentArchiveMultipleDocPutBody} documentArchiveMultipleDocPutBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut(documentArchiveMultipleDocPutBody: DocumentArchiveMultipleDocPutBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut(documentArchiveMultipleDocPutBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add New Bot
         * @param {Bot} bot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewBotBotsCreatePost(bot: Bot, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPublicInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewBotBotsCreatePost(bot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add New User
         * @param {string} userId 
         * @param {string} displayName 
         * @param {string} email 
         * @param {string} photoUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewUserAdminAddNewUserPost(userId: string, displayName: string, email: string, photoUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewUserAdminAddNewUserPost(userId, displayName, email, photoUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Pinecone Index
         * @param {PineconeIndex} pineconeIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPineconeIndexVectorstoresPineconeIndicesPost(pineconeIndex: PineconeIndex, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPineconeIndexVectorstoresPineconeIndicesPost(pineconeIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Public Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPublicBotBotsAddedBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAddPublicBotBotsAddedBotIdGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPublicBotBotsAddedBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete Wix Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWixLoginCompleteWixLoginGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWixLoginCompleteWixLoginGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirm Image Upload
         * @param {any} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmImageUploadUtilsConfirmImageUploadImageNamePut(imageName: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmImageUploadUtilsConfirmImageUploadImageNamePut(imageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Email Connection
         * @param {EmailConnection} emailConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailConnectionConnectionsEmailPost(emailConnection: EmailConnection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailConnectionConnectionsEmailPost(emailConnection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete All Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllDataAdminDeleteAllDataDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllDataAdminDeleteAllDataDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectionConnectionsDeleteConnectionIdDelete(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnectionConnectionsDeleteConnectionIdDelete(connectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Conversation
         * @param {string} botId 
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationDeleteConvByIdBotIdConversationIdDelete(botId: string, conversationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversationDeleteConvByIdBotIdConversationIdDelete(botId, conversationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Document Archive
         * @param {string} documentArchiveId 
         * @param {boolean} [deleteFromPinecone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete(documentArchiveId: string, deleteFromPinecone?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete(documentArchiveId, deleteFromPinecone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Document Archive File
         * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentArchiveFileDocumentArchiveFilePut(documentArchiveRESTBody: DocumentArchiveRESTBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentArchiveFileDocumentArchiveFilePut(documentArchiveRESTBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Pinecone Document
         * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePineconeDocumentDocumentPineconeFilePut(documentArchiveRESTBody: DocumentArchiveRESTBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePineconeDocumentDocumentPineconeFilePut(documentArchiveRESTBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete User Bot
         * @param {any} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserBotBotsByIdBotIdDelete(botId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserBotBotsByIdBotIdDelete(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Describe Pinecone Index
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Externaly Modify Bot
         * @param {ExternalBotModificationRESTBody} externalBotModificationRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalyModifyBotExternalModifyBotPut(externalBotModificationRESTBody: ExternalBotModificationRESTBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPublicInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalyModifyBotExternalModifyBotPut(externalBotModificationRESTBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate Email
         * @param {number} numberOfWords 
         * @param {string} name 
         * @param {number} [numberOfAttempts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateEmailUtilsGenerateEmailGet(numberOfWords: number, name: string, numberOfAttempts?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateEmailUtilsGenerateEmailGet(numberOfWords, name, numberOfAttempts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate Presigned Url
         * @param {string} objectName 
         * @param {string} objectType 
         * @param {boolean} [docUpload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePresignedUrlUtilsGenerateS3UploadUrlGet(objectName: string, objectType: string, docUpload?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePresignedUrlUtilsGenerateS3UploadUrlGet(objectName, objectType, docUpload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate Single Use Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSingleUseTokenSecretsGenerateSingleUseTokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSingleUseTokenSecretsGenerateSingleUseTokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Added Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddedBotsBotsAddedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotPublicInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddedBotsBotsAddedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get All Bot Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBotTypeBotTypesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBotTypeBotTypesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get All Bots For User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBotsForUserBotsAllbotsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotPublicInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBotsForUserBotsAllbotsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bot
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotBotsByIdIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPublicInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotBotsByIdIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bot Connections
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotConnectionsConnectionsGetAllBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotConnectionsConnectionsGetAllBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bot Photo Url
         * @param {string} botId 
         * @param {number} [secondsToExpiry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotPhotoUrlBotsBotPhotoUrlBotIdGet(botId: string, secondsToExpiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPhotoURL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotPhotoUrlBotsBotPhotoUrlBotIdGet(botId, secondsToExpiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bot Shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotShortcutsShortcutsGetAllGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortCutList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotShortcutsShortcutsGetAllGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bot Type
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotTypeBotTypesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotTypeBotTypesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bots
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotsBotsByIdsGet(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotPublicInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotsBotsByIdsGet(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Bots For Storefront
         * @param {string} storefrontId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet(storefrontId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotPublicInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet(storefrontId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Builtin Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuiltinBotsListAllSystemBotsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuiltinBotsListAllSystemBotsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Conversations By User
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationsByUserConversationsBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conversation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationsByUserConversationsBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Document Archive From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Document Archives
         * @param {string} [docId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentArchivesDocumentArchivesGet(docId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentArchive>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentArchivesDocumentArchivesGet(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Init Values From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Messages By Conversation
         * @param {string} botId 
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesByConversationConversationsByIdBotIdConversationIdGet(botId: string, conversationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesByConversationConversationsByIdBotIdConversationIdGet(botId, conversationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Paginated Bots Added
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedBotsAddedBotsPaginateAddedGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedBotsAddedBotsPaginateAddedGet(cursor, limit, orderBy, isAsc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Paginated Bots Shared
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedBotsSharedBotsPaginateSharedGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedBotsSharedBotsPaginateSharedGet(cursor, limit, orderBy, isAsc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Paginated Bots User
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedBotsUserBotsPaginateUserGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedBotsUserBotsPaginateUserGet(cursor, limit, orderBy, isAsc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Pinecone Index
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPineconeIndexVectorstoresDescribePineconeIndicesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PineconeIndex>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPineconeIndexVectorstoresDescribePineconeIndicesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Pinecone Index
         * @param {string} indexId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPineconeIndexVectorstoresPineconeIndicesIndexIdGet(indexId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PineconeIndex>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPineconeIndexVectorstoresPineconeIndicesIndexIdGet(indexId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Pinecone Indices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPineconeIndicesVectorstoresPineconeIndicesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PineconeIndex>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPineconeIndicesVectorstoresPineconeIndicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Pinecone Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPineconeUsageUsersVectorstoresPineconeUsageGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PineconeUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPineconeUsageUsersVectorstoresPineconeUsageGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Server Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerSecretSecretsRefreshGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSecretSecretsRefreshGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Setup Values From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Shared Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedBotsBotsAllSharedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotPublicInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedBotsBotsAllSharedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Shortcut Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShortcutBotsBotsGetShortcutBotsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotPublicInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShortcutBotsBotsGetShortcutBotsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Store Front
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreFrontUsersStorefrontGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storefront>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreFrontUsersStorefrontGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Token Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenBalanceUsersGetTokenBalanceGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenQuantity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBalanceUsersGetTokenBalanceGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Token Rate
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenRateBotsGetTokenRateBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenQuantity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenRateBotsGetTokenRateBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBotsBotsUserbotsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBotsBotsUserbotsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfoUsersGetUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoUsersGetUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Ws Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWsTicketGetWsTicketGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWsTicketGetWsTicketGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Is Authed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAuthedIsAuthedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: boolean; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAuthedIsAuthedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Is Storefront Used
         * @param {string} storefrontId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet(storefrontId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet(storefrontId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {LogIn} logIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginLoginPost(logIn: LogIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginLoginPost(logIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login With Storefront
         * @param {StorefrontLogin} storefrontLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginWithStorefrontLoginWithStorefrontPost(storefrontLogin: StorefrontLogin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithStorefrontLoginWithStorefrontPost(storefrontLogin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout
         * @param {boolean} [fromAllDevices] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutLogoutGet(fromAllDevices?: boolean, refreshToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutLogoutGet(fromAllDevices, refreshToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Make Bot Private
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeBotPrivateBotsMakeBotPrivateBotIdPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPublicInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeBotPrivateBotsMakeBotPrivateBotIdPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Make Bot Public
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeBotPublicBotsMakeBotPublicBotIdPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPublicInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeBotPublicBotsMakeBotPublicBotIdPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify Storefront
         * @param {Storefront} storefront 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyStorefrontUtilsModifyStorefrontPut(storefront: Storefront, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storefront>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyStorefrontUtilsModifyStorefrontPut(storefront, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Open Shared Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openSharedBotBotsSharedBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotPublicInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openSharedBotBotsSharedBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge All Document Archives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge All Messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeAllMessagesAdminPurgeAllMessagesDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAllMessagesAdminPurgeAllMessagesDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge All Namespaces And Doc Archives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge All User Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeAllUserBotsAdminPurgeAllUserBotsDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAllUserBotsAdminPurgeAllUserBotsDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readHealthHealthGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readHealthHealthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh Token Endpoint
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTokenEndpointRefreshTokenPost(refreshToken: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTokenEndpointRefreshTokenPost(refreshToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Added Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAddedBotBotsRemoveAddedBotIdPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAddedBotBotsRemoveAddedBotIdPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Bot From Shortcuts
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBotFromShortcutsShortcutsRemoveBotPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBotFromShortcutsShortcutsRemoveBotPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Server Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeServerSecretSecretsDeleteDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeServerSecretSecretsDeleteDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Report Build Failure
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportBuildFailureBotsReportBuildFailureBotIdPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportBuildFailureBotsReportBuildFailureBotIdPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Report Build Success
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportBuildSuccessBotsReportBuildSuccessBotIdPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportBuildSuccessBotsReportBuildSuccessBotIdPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetAdminUsersResetAdminPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetAdminUsersResetAdminPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset All Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetAllDataAdminResetAllDataPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetAllDataAdminResetAllDataPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Bot Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetBotTypesAdminRestoreBotTypesPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetBotTypesAdminRestoreBotTypesPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Bots
         * @param {boolean} [updateDocs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetBotsAdminRestoreBuiltinBotsPut(updateDocs?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetBotsAdminRestoreBuiltinBotsPut(updateDocs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Bots And Bot Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetBotsAndBotTypesAdminResetBotsAndBotTypesPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetBotsAndBotTypesAdminResetBotsAndBotTypesPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Pinecone Indices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPineconeIndicesAdminResetPineconeIndicesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPineconeIndicesAdminResetPineconeIndicesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start Bot Share
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startBotShareBotsStartShareBotIdGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startBotShareBotsStartShareBotIdGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start Wix Login
         * @param {LogIn} logIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startWixLoginStartWixLoginPost(logIn: LogIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startWixLoginStartWixLoginPost(logIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop Bot Share
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopBotShareBotsStopShareBotIdPut(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopBotShareBotsStopShareBotIdPut(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stripe Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeWebhookWebhookStripePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeWebhookWebhookStripePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Bot Status
         * @param {string} id 
         * @param {BotStatus} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBotStatusBotsUpdateBotStatusIdPut(id: string, status: BotStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBotStatusBotsUpdateBotStatusIdPut(id, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Bot To Shortcuts
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBotToShortcutsShortcutsAddBotPut(botId: string, options?: any): AxiosPromise<void> {
            return localVarFp.addBotToShortcutsShortcutsAddBotPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Document Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentArchiveDocumentArchivesUsersPost(options?: any): AxiosPromise<DocumentArchive> {
            return localVarFp.addDocumentArchiveDocumentArchivesUsersPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Multiple Documents To Doc Archive
         * @param {DocumentArchiveMultipleDocPutBody} documentArchiveMultipleDocPutBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut(documentArchiveMultipleDocPutBody: DocumentArchiveMultipleDocPutBody, options?: any): AxiosPromise<object> {
            return localVarFp.addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut(documentArchiveMultipleDocPutBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add New Bot
         * @param {Bot} bot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewBotBotsCreatePost(bot: Bot, options?: any): AxiosPromise<BotPublicInterface> {
            return localVarFp.addNewBotBotsCreatePost(bot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add New User
         * @param {string} userId 
         * @param {string} displayName 
         * @param {string} email 
         * @param {string} photoUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewUserAdminAddNewUserPost(userId: string, displayName: string, email: string, photoUrl: string, options?: any): AxiosPromise<UserInfo> {
            return localVarFp.addNewUserAdminAddNewUserPost(userId, displayName, email, photoUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Pinecone Index
         * @param {PineconeIndex} pineconeIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPineconeIndexVectorstoresPineconeIndicesPost(pineconeIndex: PineconeIndex, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.addPineconeIndexVectorstoresPineconeIndicesPost(pineconeIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Public Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPublicBotBotsAddedBotIdGet(botId: string, options?: any): AxiosPromise<ResponseAddPublicBotBotsAddedBotIdGet> {
            return localVarFp.addPublicBotBotsAddedBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete Wix Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWixLoginCompleteWixLoginGet(options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.completeWixLoginCompleteWixLoginGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm Image Upload
         * @param {any} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmImageUploadUtilsConfirmImageUploadImageNamePut(imageName: any, options?: any): AxiosPromise<void> {
            return localVarFp.confirmImageUploadUtilsConfirmImageUploadImageNamePut(imageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Email Connection
         * @param {EmailConnection} emailConnection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailConnectionConnectionsEmailPost(emailConnection: EmailConnection, options?: any): AxiosPromise<EmailConnection> {
            return localVarFp.createEmailConnectionConnectionsEmailPost(emailConnection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete All Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllDataAdminDeleteAllDataDelete(options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllDataAdminDeleteAllDataDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionConnectionsDeleteConnectionIdDelete(connectionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConnectionConnectionsDeleteConnectionIdDelete(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Conversation
         * @param {string} botId 
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationDeleteConvByIdBotIdConversationIdDelete(botId: string, conversationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConversationDeleteConvByIdBotIdConversationIdDelete(botId, conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Document Archive
         * @param {string} documentArchiveId 
         * @param {boolean} [deleteFromPinecone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete(documentArchiveId: string, deleteFromPinecone?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete(documentArchiveId, deleteFromPinecone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Document Archive File
         * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentArchiveFileDocumentArchiveFilePut(documentArchiveRESTBody: DocumentArchiveRESTBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentArchiveFileDocumentArchiveFilePut(documentArchiveRESTBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Pinecone Document
         * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePineconeDocumentDocumentPineconeFilePut(documentArchiveRESTBody: DocumentArchiveRESTBody, options?: any): AxiosPromise<void> {
            return localVarFp.deletePineconeDocumentDocumentPineconeFilePut(documentArchiveRESTBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User Bot
         * @param {any} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserBotBotsByIdBotIdDelete(botId: any, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserBotBotsByIdBotIdDelete(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Describe Pinecone Index
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Externaly Modify Bot
         * @param {ExternalBotModificationRESTBody} externalBotModificationRESTBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalyModifyBotExternalModifyBotPut(externalBotModificationRESTBody: ExternalBotModificationRESTBody, options?: any): AxiosPromise<BotPublicInterface> {
            return localVarFp.externalyModifyBotExternalModifyBotPut(externalBotModificationRESTBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Email
         * @param {number} numberOfWords 
         * @param {string} name 
         * @param {number} [numberOfAttempts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEmailUtilsGenerateEmailGet(numberOfWords: number, name: string, numberOfAttempts?: number, options?: any): AxiosPromise<Message> {
            return localVarFp.generateEmailUtilsGenerateEmailGet(numberOfWords, name, numberOfAttempts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Presigned Url
         * @param {string} objectName 
         * @param {string} objectType 
         * @param {boolean} [docUpload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePresignedUrlUtilsGenerateS3UploadUrlGet(objectName: string, objectType: string, docUpload?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.generatePresignedUrlUtilsGenerateS3UploadUrlGet(objectName, objectType, docUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Single Use Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSingleUseTokenSecretsGenerateSingleUseTokenGet(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.generateSingleUseTokenSecretsGenerateSingleUseTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Added Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddedBotsBotsAddedGet(options?: any): AxiosPromise<Array<BotPublicInterface>> {
            return localVarFp.getAddedBotsBotsAddedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Bot Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBotTypeBotTypesGet(options?: any): AxiosPromise<Array<BotType>> {
            return localVarFp.getAllBotTypeBotTypesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Bots For User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBotsForUserBotsAllbotsGet(options?: any): AxiosPromise<Array<BotPublicInterface>> {
            return localVarFp.getAllBotsForUserBotsAllbotsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bot
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotBotsByIdIdGet(id: string, options?: any): AxiosPromise<BotPublicInterface> {
            return localVarFp.getBotBotsByIdIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bot Connections
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotConnectionsConnectionsGetAllBotIdGet(botId: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getBotConnectionsConnectionsGetAllBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bot Photo Url
         * @param {string} botId 
         * @param {number} [secondsToExpiry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotPhotoUrlBotsBotPhotoUrlBotIdGet(botId: string, secondsToExpiry?: number, options?: any): AxiosPromise<BotPhotoURL> {
            return localVarFp.getBotPhotoUrlBotsBotPhotoUrlBotIdGet(botId, secondsToExpiry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bot Shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotShortcutsShortcutsGetAllGet(options?: any): AxiosPromise<ShortCutList> {
            return localVarFp.getBotShortcutsShortcutsGetAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bot Type
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotTypeBotTypesIdGet(id: string, options?: any): AxiosPromise<BotType> {
            return localVarFp.getBotTypeBotTypesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bots
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotsBotsByIdsGet(requestBody: Array<string>, options?: any): AxiosPromise<Array<BotPublicInterface>> {
            return localVarFp.getBotsBotsByIdsGet(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Bots For Storefront
         * @param {string} storefrontId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet(storefrontId: string, options?: any): AxiosPromise<Array<BotPublicInterface>> {
            return localVarFp.getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet(storefrontId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Builtin Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltinBotsListAllSystemBotsGet(options?: any): AxiosPromise<Array<Bot>> {
            return localVarFp.getBuiltinBotsListAllSystemBotsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Conversations By User
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationsByUserConversationsBotIdGet(botId: string, options?: any): AxiosPromise<Array<Conversation>> {
            return localVarFp.getConversationsByUserConversationsBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Document Archive From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet(botId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Document Archives
         * @param {string} [docId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentArchivesDocumentArchivesGet(docId?: string, options?: any): AxiosPromise<Array<DocumentArchive>> {
            return localVarFp.getDocumentArchivesDocumentArchivesGet(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Init Values From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet(botId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Messages By Conversation
         * @param {string} botId 
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesByConversationConversationsByIdBotIdConversationIdGet(botId: string, conversationId: string, options?: any): AxiosPromise<ChatHistory> {
            return localVarFp.getMessagesByConversationConversationsByIdBotIdConversationIdGet(botId, conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Paginated Bots Added
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBotsAddedBotsPaginateAddedGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: any): AxiosPromise<BotPage> {
            return localVarFp.getPaginatedBotsAddedBotsPaginateAddedGet(cursor, limit, orderBy, isAsc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Paginated Bots Shared
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBotsSharedBotsPaginateSharedGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: any): AxiosPromise<BotPage> {
            return localVarFp.getPaginatedBotsSharedBotsPaginateSharedGet(cursor, limit, orderBy, isAsc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Paginated Bots User
         * @param {string} [cursor] Cursor for paginated results
         * @param {number} [limit] Maximum number of items to return
         * @param {string} [orderBy] Property to order the results by
         * @param {boolean} [isAsc] Should the results be in ascending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBotsUserBotsPaginateUserGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: any): AxiosPromise<BotPage> {
            return localVarFp.getPaginatedBotsUserBotsPaginateUserGet(cursor, limit, orderBy, isAsc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Pinecone Index
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeIndexVectorstoresDescribePineconeIndicesIdGet(id: string, options?: any): AxiosPromise<PineconeIndex> {
            return localVarFp.getPineconeIndexVectorstoresDescribePineconeIndicesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Pinecone Index
         * @param {string} indexId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeIndexVectorstoresPineconeIndicesIndexIdGet(indexId: string, options?: any): AxiosPromise<Array<PineconeIndex>> {
            return localVarFp.getPineconeIndexVectorstoresPineconeIndicesIndexIdGet(indexId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Pinecone Indices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeIndicesVectorstoresPineconeIndicesGet(options?: any): AxiosPromise<Array<PineconeIndex>> {
            return localVarFp.getPineconeIndicesVectorstoresPineconeIndicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Pinecone Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPineconeUsageUsersVectorstoresPineconeUsageGet(options?: any): AxiosPromise<PineconeUsage> {
            return localVarFp.getPineconeUsageUsersVectorstoresPineconeUsageGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Server Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSecretSecretsRefreshGet(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getServerSecretSecretsRefreshGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Setup Values From Public Id User Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet(botId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Shared Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedBotsBotsAllSharedGet(options?: any): AxiosPromise<Array<BotPublicInterface>> {
            return localVarFp.getSharedBotsBotsAllSharedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Shortcut Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortcutBotsBotsGetShortcutBotsGet(options?: any): AxiosPromise<Array<BotPublicInterface>> {
            return localVarFp.getShortcutBotsBotsGetShortcutBotsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Store Front
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFrontUsersStorefrontGet(options?: any): AxiosPromise<Array<Storefront>> {
            return localVarFp.getStoreFrontUsersStorefrontGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBalanceUsersGetTokenBalanceGet(options?: any): AxiosPromise<TokenQuantity> {
            return localVarFp.getTokenBalanceUsersGetTokenBalanceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token Rate
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenRateBotsGetTokenRateBotIdGet(botId: string, options?: any): AxiosPromise<TokenQuantity> {
            return localVarFp.getTokenRateBotsGetTokenRateBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBotsBotsUserbotsGet(options?: any): AxiosPromise<Array<Bot>> {
            return localVarFp.getUserBotsBotsUserbotsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoUsersGetUserGet(options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getUserInfoUsersGetUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ws Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWsTicketGetWsTicketGet(options?: any): AxiosPromise<SessionToken> {
            return localVarFp.getWsTicketGetWsTicketGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Authed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAuthedIsAuthedGet(options?: any): AxiosPromise<{ [key: string]: boolean; }> {
            return localVarFp.isAuthedIsAuthedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Storefront Used
         * @param {string} storefrontId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet(storefrontId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet(storefrontId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LogIn} logIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(logIn: LogIn, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.loginLoginPost(logIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login With Storefront
         * @param {StorefrontLogin} storefrontLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithStorefrontLoginWithStorefrontPost(storefrontLogin: StorefrontLogin, options?: any): AxiosPromise<string> {
            return localVarFp.loginWithStorefrontLoginWithStorefrontPost(storefrontLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {boolean} [fromAllDevices] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutLogoutGet(fromAllDevices?: boolean, refreshToken?: string, options?: any): AxiosPromise<object> {
            return localVarFp.logoutLogoutGet(fromAllDevices, refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Make Bot Private
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeBotPrivateBotsMakeBotPrivateBotIdPut(botId: string, options?: any): AxiosPromise<BotPublicInterface> {
            return localVarFp.makeBotPrivateBotsMakeBotPrivateBotIdPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Make Bot Public
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeBotPublicBotsMakeBotPublicBotIdPut(botId: string, options?: any): AxiosPromise<BotPublicInterface> {
            return localVarFp.makeBotPublicBotsMakeBotPublicBotIdPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify Storefront
         * @param {Storefront} storefront 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyStorefrontUtilsModifyStorefrontPut(storefront: Storefront, options?: any): AxiosPromise<Storefront> {
            return localVarFp.modifyStorefrontUtilsModifyStorefrontPut(storefront, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open Shared Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openSharedBotBotsSharedBotIdGet(botId: string, options?: any): AxiosPromise<BotPublicInterface> {
            return localVarFp.openSharedBotBotsSharedBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge All Document Archives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete(options?: any): AxiosPromise<void> {
            return localVarFp.purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge All Messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllMessagesAdminPurgeAllMessagesDelete(options?: any): AxiosPromise<void> {
            return localVarFp.purgeAllMessagesAdminPurgeAllMessagesDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge All Namespaces And Doc Archives
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete(options?: any): AxiosPromise<void> {
            return localVarFp.purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge All User Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllUserBotsAdminPurgeAllUserBotsDelete(options?: any): AxiosPromise<void> {
            return localVarFp.purgeAllUserBotsAdminPurgeAllUserBotsDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHealthHealthGet(options?: any): AxiosPromise<any> {
            return localVarFp.readHealthHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Token Endpoint
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenEndpointRefreshTokenPost(refreshToken: string, options?: any): AxiosPromise<SessionToken> {
            return localVarFp.refreshTokenEndpointRefreshTokenPost(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Added Bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAddedBotBotsRemoveAddedBotIdPut(botId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAddedBotBotsRemoveAddedBotIdPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Bot From Shortcuts
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBotFromShortcutsShortcutsRemoveBotPut(botId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeBotFromShortcutsShortcutsRemoveBotPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Server Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeServerSecretSecretsDeleteDelete(options?: any): AxiosPromise<void> {
            return localVarFp.removeServerSecretSecretsDeleteDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Report Build Failure
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportBuildFailureBotsReportBuildFailureBotIdPut(botId: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportBuildFailureBotsReportBuildFailureBotIdPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Report Build Success
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportBuildSuccessBotsReportBuildSuccessBotIdPut(botId: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportBuildSuccessBotsReportBuildSuccessBotIdPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAdminUsersResetAdminPut(options?: any): AxiosPromise<void> {
            return localVarFp.resetAdminUsersResetAdminPut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset All Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAllDataAdminResetAllDataPut(options?: any): AxiosPromise<void> {
            return localVarFp.resetAllDataAdminResetAllDataPut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Bot Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetBotTypesAdminRestoreBotTypesPut(options?: any): AxiosPromise<void> {
            return localVarFp.resetBotTypesAdminRestoreBotTypesPut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Bots
         * @param {boolean} [updateDocs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetBotsAdminRestoreBuiltinBotsPut(updateDocs?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.resetBotsAdminRestoreBuiltinBotsPut(updateDocs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Bots And Bot Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetBotsAndBotTypesAdminResetBotsAndBotTypesPut(options?: any): AxiosPromise<void> {
            return localVarFp.resetBotsAndBotTypesAdminResetBotsAndBotTypesPut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Pinecone Indices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPineconeIndicesAdminResetPineconeIndicesPost(options?: any): AxiosPromise<void> {
            return localVarFp.resetPineconeIndicesAdminResetPineconeIndicesPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start Bot Share
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBotShareBotsStartShareBotIdGet(botId: string, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.startBotShareBotsStartShareBotIdGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start Wix Login
         * @param {LogIn} logIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startWixLoginStartWixLoginPost(logIn: LogIn, options?: any): AxiosPromise<string> {
            return localVarFp.startWixLoginStartWixLoginPost(logIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop Bot Share
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBotShareBotsStopShareBotIdPut(botId: string, options?: any): AxiosPromise<void> {
            return localVarFp.stopBotShareBotsStopShareBotIdPut(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stripe Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeWebhookWebhookStripePost(options?: any): AxiosPromise<Message> {
            return localVarFp.stripeWebhookWebhookStripePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Bot Status
         * @param {string} id 
         * @param {BotStatus} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotStatusBotsUpdateBotStatusIdPut(id: string, status: BotStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateBotStatusBotsUpdateBotStatusIdPut(id, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add Bot To Shortcuts
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addBotToShortcutsShortcutsAddBotPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addBotToShortcutsShortcutsAddBotPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Document Archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addDocumentArchiveDocumentArchivesUsersPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addDocumentArchiveDocumentArchivesUsersPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Multiple Documents To Doc Archive
     * @param {DocumentArchiveMultipleDocPutBody} documentArchiveMultipleDocPutBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut(documentArchiveMultipleDocPutBody: DocumentArchiveMultipleDocPutBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addMultipleDocumentsToDocArchiveDocumentArchivesMultidocUsersPut(documentArchiveMultipleDocPutBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add New Bot
     * @param {Bot} bot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addNewBotBotsCreatePost(bot: Bot, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addNewBotBotsCreatePost(bot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add New User
     * @param {string} userId 
     * @param {string} displayName 
     * @param {string} email 
     * @param {string} photoUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addNewUserAdminAddNewUserPost(userId: string, displayName: string, email: string, photoUrl: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addNewUserAdminAddNewUserPost(userId, displayName, email, photoUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Pinecone Index
     * @param {PineconeIndex} pineconeIndex 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addPineconeIndexVectorstoresPineconeIndicesPost(pineconeIndex: PineconeIndex, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addPineconeIndexVectorstoresPineconeIndicesPost(pineconeIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Public Bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addPublicBotBotsAddedBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addPublicBotBotsAddedBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete Wix Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public completeWixLoginCompleteWixLoginGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).completeWixLoginCompleteWixLoginGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm Image Upload
     * @param {any} imageName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public confirmImageUploadUtilsConfirmImageUploadImageNamePut(imageName: any, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).confirmImageUploadUtilsConfirmImageUploadImageNamePut(imageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Email Connection
     * @param {EmailConnection} emailConnection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createEmailConnectionConnectionsEmailPost(emailConnection: EmailConnection, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createEmailConnectionConnectionsEmailPost(emailConnection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete All Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAllDataAdminDeleteAllDataDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAllDataAdminDeleteAllDataDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteConnectionConnectionsDeleteConnectionIdDelete(connectionId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteConnectionConnectionsDeleteConnectionIdDelete(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Conversation
     * @param {string} botId 
     * @param {string} conversationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteConversationDeleteConvByIdBotIdConversationIdDelete(botId: string, conversationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteConversationDeleteConvByIdBotIdConversationIdDelete(botId, conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Document Archive
     * @param {string} documentArchiveId 
     * @param {boolean} [deleteFromPinecone] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete(documentArchiveId: string, deleteFromPinecone?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteDocumentArchiveDocumentArchiveDocumentArchiveIdDelete(documentArchiveId, deleteFromPinecone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Document Archive File
     * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteDocumentArchiveFileDocumentArchiveFilePut(documentArchiveRESTBody: DocumentArchiveRESTBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteDocumentArchiveFileDocumentArchiveFilePut(documentArchiveRESTBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Pinecone Document
     * @param {DocumentArchiveRESTBody} documentArchiveRESTBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deletePineconeDocumentDocumentPineconeFilePut(documentArchiveRESTBody: DocumentArchiveRESTBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePineconeDocumentDocumentPineconeFilePut(documentArchiveRESTBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User Bot
     * @param {any} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUserBotBotsByIdBotIdDelete(botId: any, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUserBotBotsByIdBotIdDelete(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Describe Pinecone Index
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).describePineconeIndexVectorstoresPineconeIndicesIdDescribeGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Externaly Modify Bot
     * @param {ExternalBotModificationRESTBody} externalBotModificationRESTBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public externalyModifyBotExternalModifyBotPut(externalBotModificationRESTBody: ExternalBotModificationRESTBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).externalyModifyBotExternalModifyBotPut(externalBotModificationRESTBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Email
     * @param {number} numberOfWords 
     * @param {string} name 
     * @param {number} [numberOfAttempts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateEmailUtilsGenerateEmailGet(numberOfWords: number, name: string, numberOfAttempts?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateEmailUtilsGenerateEmailGet(numberOfWords, name, numberOfAttempts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Presigned Url
     * @param {string} objectName 
     * @param {string} objectType 
     * @param {boolean} [docUpload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generatePresignedUrlUtilsGenerateS3UploadUrlGet(objectName: string, objectType: string, docUpload?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generatePresignedUrlUtilsGenerateS3UploadUrlGet(objectName, objectType, docUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Single Use Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateSingleUseTokenSecretsGenerateSingleUseTokenGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateSingleUseTokenSecretsGenerateSingleUseTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Added Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAddedBotsBotsAddedGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAddedBotsBotsAddedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Bot Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllBotTypeBotTypesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllBotTypeBotTypesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Bots For User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllBotsForUserBotsAllbotsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllBotsForUserBotsAllbotsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bot
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotBotsByIdIdGet(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotBotsByIdIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bot Connections
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotConnectionsConnectionsGetAllBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotConnectionsConnectionsGetAllBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bot Photo Url
     * @param {string} botId 
     * @param {number} [secondsToExpiry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotPhotoUrlBotsBotPhotoUrlBotIdGet(botId: string, secondsToExpiry?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotPhotoUrlBotsBotPhotoUrlBotIdGet(botId, secondsToExpiry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bot Shortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotShortcutsShortcutsGetAllGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotShortcutsShortcutsGetAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bot Type
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotTypeBotTypesIdGet(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotTypeBotTypesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bots
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotsBotsByIdsGet(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotsBotsByIdsGet(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Bots For Storefront
     * @param {string} storefrontId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet(storefrontId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBotsForStorefrontBotsGetBotsForStorefrontStorefrontIdGet(storefrontId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Builtin Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBuiltinBotsListAllSystemBotsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBuiltinBotsListAllSystemBotsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Conversations By User
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConversationsByUserConversationsBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getConversationsByUserConversationsBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Document Archive From Public Id User Bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDocumentArchiveFromPublicIdUserBotBotsGetUserBotDocumentArchiveIdBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Document Archives
     * @param {string} [docId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentArchivesDocumentArchivesGet(docId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDocumentArchivesDocumentArchivesGet(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Init Values From Public Id User Bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInitValuesFromPublicIdUserBotBotsGetUserBotInitValuesBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Messages By Conversation
     * @param {string} botId 
     * @param {string} conversationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMessagesByConversationConversationsByIdBotIdConversationIdGet(botId: string, conversationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMessagesByConversationConversationsByIdBotIdConversationIdGet(botId, conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Paginated Bots Added
     * @param {string} [cursor] Cursor for paginated results
     * @param {number} [limit] Maximum number of items to return
     * @param {string} [orderBy] Property to order the results by
     * @param {boolean} [isAsc] Should the results be in ascending order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPaginatedBotsAddedBotsPaginateAddedGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPaginatedBotsAddedBotsPaginateAddedGet(cursor, limit, orderBy, isAsc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Paginated Bots Shared
     * @param {string} [cursor] Cursor for paginated results
     * @param {number} [limit] Maximum number of items to return
     * @param {string} [orderBy] Property to order the results by
     * @param {boolean} [isAsc] Should the results be in ascending order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPaginatedBotsSharedBotsPaginateSharedGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPaginatedBotsSharedBotsPaginateSharedGet(cursor, limit, orderBy, isAsc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Paginated Bots User
     * @param {string} [cursor] Cursor for paginated results
     * @param {number} [limit] Maximum number of items to return
     * @param {string} [orderBy] Property to order the results by
     * @param {boolean} [isAsc] Should the results be in ascending order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPaginatedBotsUserBotsPaginateUserGet(cursor?: string, limit?: number, orderBy?: string, isAsc?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPaginatedBotsUserBotsPaginateUserGet(cursor, limit, orderBy, isAsc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Pinecone Index
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPineconeIndexVectorstoresDescribePineconeIndicesIdGet(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPineconeIndexVectorstoresDescribePineconeIndicesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Pinecone Index
     * @param {string} indexId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPineconeIndexVectorstoresPineconeIndicesIndexIdGet(indexId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPineconeIndexVectorstoresPineconeIndicesIndexIdGet(indexId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Pinecone Indices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPineconeIndicesVectorstoresPineconeIndicesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPineconeIndicesVectorstoresPineconeIndicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Pinecone Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPineconeUsageUsersVectorstoresPineconeUsageGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPineconeUsageUsersVectorstoresPineconeUsageGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Server Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServerSecretSecretsRefreshGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServerSecretSecretsRefreshGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Setup Values From Public Id User Bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSetupValuesFromPublicIdUserBotBotsGetUserBotSetupValuesBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Shared Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSharedBotsBotsAllSharedGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSharedBotsBotsAllSharedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Shortcut Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getShortcutBotsBotsGetShortcutBotsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getShortcutBotsBotsGetShortcutBotsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Store Front
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreFrontUsersStorefrontGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreFrontUsersStorefrontGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenBalanceUsersGetTokenBalanceGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenBalanceUsersGetTokenBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token Rate
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenRateBotsGetTokenRateBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenRateBotsGetTokenRateBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserBotsBotsUserbotsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserBotsBotsUserbotsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserInfoUsersGetUserGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserInfoUsersGetUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ws Ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWsTicketGetWsTicketGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWsTicketGetWsTicketGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Authed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public isAuthedIsAuthedGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isAuthedIsAuthedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Storefront Used
     * @param {string} storefrontId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet(storefrontId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isStorefrontUsedUsersIsStorefrontUsedStorefrontIdGet(storefrontId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LogIn} logIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginLoginPost(logIn: LogIn, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginLoginPost(logIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login With Storefront
     * @param {StorefrontLogin} storefrontLogin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginWithStorefrontLoginWithStorefrontPost(storefrontLogin: StorefrontLogin, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginWithStorefrontLoginWithStorefrontPost(storefrontLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {boolean} [fromAllDevices] 
     * @param {string} [refreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logoutLogoutGet(fromAllDevices?: boolean, refreshToken?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logoutLogoutGet(fromAllDevices, refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Make Bot Private
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public makeBotPrivateBotsMakeBotPrivateBotIdPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).makeBotPrivateBotsMakeBotPrivateBotIdPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Make Bot Public
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public makeBotPublicBotsMakeBotPublicBotIdPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).makeBotPublicBotsMakeBotPublicBotIdPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify Storefront
     * @param {Storefront} storefront 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public modifyStorefrontUtilsModifyStorefrontPut(storefront: Storefront, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).modifyStorefrontUtilsModifyStorefrontPut(storefront, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open Shared Bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public openSharedBotBotsSharedBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).openSharedBotBotsSharedBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge All Document Archives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).purgeAllDocumentArchivesAdminPurgeAllDocArchivesDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge All Messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public purgeAllMessagesAdminPurgeAllMessagesDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).purgeAllMessagesAdminPurgeAllMessagesDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge All Namespaces And Doc Archives
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).purgeAllNamespacesAndDocArchivesAdminPurgeAllDocArchivesAndNamespacesDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge All User Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public purgeAllUserBotsAdminPurgeAllUserBotsDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).purgeAllUserBotsAdminPurgeAllUserBotsDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public readHealthHealthGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).readHealthHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Token Endpoint
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshTokenEndpointRefreshTokenPost(refreshToken: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshTokenEndpointRefreshTokenPost(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Added Bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeAddedBotBotsRemoveAddedBotIdPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeAddedBotBotsRemoveAddedBotIdPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Bot From Shortcuts
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeBotFromShortcutsShortcutsRemoveBotPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeBotFromShortcutsShortcutsRemoveBotPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Server Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeServerSecretSecretsDeleteDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeServerSecretSecretsDeleteDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Report Build Failure
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reportBuildFailureBotsReportBuildFailureBotIdPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reportBuildFailureBotsReportBuildFailureBotIdPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Report Build Success
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reportBuildSuccessBotsReportBuildSuccessBotIdPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reportBuildSuccessBotsReportBuildSuccessBotIdPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetAdminUsersResetAdminPut(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetAdminUsersResetAdminPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset All Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetAllDataAdminResetAllDataPut(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetAllDataAdminResetAllDataPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Bot Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetBotTypesAdminRestoreBotTypesPut(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetBotTypesAdminRestoreBotTypesPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Bots
     * @param {boolean} [updateDocs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetBotsAdminRestoreBuiltinBotsPut(updateDocs?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetBotsAdminRestoreBuiltinBotsPut(updateDocs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Bots And Bot Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetBotsAndBotTypesAdminResetBotsAndBotTypesPut(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetBotsAndBotTypesAdminResetBotsAndBotTypesPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Pinecone Indices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetPineconeIndicesAdminResetPineconeIndicesPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPineconeIndicesAdminResetPineconeIndicesPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start Bot Share
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startBotShareBotsStartShareBotIdGet(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startBotShareBotsStartShareBotIdGet(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start Wix Login
     * @param {LogIn} logIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startWixLoginStartWixLoginPost(logIn: LogIn, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startWixLoginStartWixLoginPost(logIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop Bot Share
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stopBotShareBotsStopShareBotIdPut(botId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stopBotShareBotsStopShareBotIdPut(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stripe Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stripeWebhookWebhookStripePost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stripeWebhookWebhookStripePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Bot Status
     * @param {string} id 
     * @param {BotStatus} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateBotStatusBotsUpdateBotStatusIdPut(id: string, status: BotStatus, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBotStatusBotsUpdateBotStatusIdPut(id, status, options).then((request) => request(this.axios, this.basePath));
    }
}


